<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="root"></div>
    <script>
        const rootDom = document.getElementById("root");

        function updateDomProperties(dom, prevProps, nextProps) {
            const isEvent = name => name.startsWith("on");
            const isAttribute = name => !isEvent(name) && name != "children";

            // preProps Remove
            // Remove event listeners
            Object.keys(prevProps).filter(isEvent).forEach(name => {
                const eventType = name.toLowerCase().substring(2);
                dom.removeEventListener(eventType, prevProps[name]);
            });

            // Remove attributes
            Object.keys(prevProps).filter(isAttribute).forEach(name => {
                dom[name] = null;
            });

            // nextProps Add
            // Set attributes
            Object.keys(nextProps).filter(isAttribute).forEach(name => {
                dom[name] = nextProps[name];
            });

            // Add event listeners
            Object.keys(nextProps).filter(isEvent).forEach(name => {
                const eventType = name.toLowerCase().substring(2);
                dom.addEventListener(eventType, nextProps[name]);
            });
        }

        // --------------- è¿è¡Œä¸€æ¬¡ å¼€å§‹------
        let rootInstance = null;

        function render(element, container) {

            const prevInstance = rootInstance; // 1-è™šæ‹Ÿdomä¸»æ ‘å¹²- == null
            const nextInstance = reconcile(container, prevInstance, element);
            rootInstance = nextInstance; // 2-æ”¯æ ‘å¹²- é¢†å¤´å•¦
        }

        function reconcile(parentDom, instance, element) {
            if (instance == null) {
                // Create instance
                const newInstance = instantiate(element);
                parentDom.appendChild(newInstance.dom);
                return newInstance;
            } else if (element == null) { // <---- 1
                // Remove instance
                parentDom.removeChild(instance.dom);
                return null;
            } else if (instance.element.type === element.type) {
                // Update instance
                updateDomProperties(instance.dom, instance.element.props, element.props);
                instance.childInstances = reconcileChildren(instance, element);
                instance.element = element;
                return instance;
            } else {
                // Replace instance
                const newInstance = instantiate(element);
                parentDom.replaceChild(newInstance.dom, instance.dom);
                return newInstance;
            }
        }

        function reconcileChildren(instance, element) {
            // instance æ—§
            // element æ–°
            const dom = instance.dom;
            const childInstances = instance.childInstances;
            const nextChildElements = element.props.children || [];
            const newChildInstances = []; // æ–°çš„å­©å­æ•°ç»„

            const count = Math.max(childInstances.length, nextChildElements.length); // æ¯”è¾ƒè°-å¤§

            for (let i = 0; i < count; i++) {
                const childInstance = childInstances[i];
                const childElement = nextChildElements[i];

                // 2. é€’å½’ - ä¸Šä¸€å±‚å‡½æ•° reconcile
                const newChildInstance = reconcile(dom, childInstance, childElement);
                newChildInstances.push(newChildInstance);
            }
            return newChildInstances.filter(instance => instance != null);
        }

        // --------------- è¿è¡Œä¸€æ¬¡ ç»“æŸ------

        // ------ é€’å½’ - instantiate - è¿è¡Œä¸€æ¬¡ä»¥ä¸Š -----
        function instantiate(element) {
            const { type, props } = element;

            // Create DOM element
            const isTextElement = type === "TEXT ELEMENT";
            const dom = isTextElement
                ? document.createTextNode("")
                : document.createElement(type);

            updateDomProperties(dom, [], props); // <------

            // Instantiate and append children
            const childElements = props.children || [];

            // 2. è½¬æŠ˜ç‚¹-é€’å½’-å­©å­ -> å˜ å®ä¾‹æ•°ç»„
            const childInstances = childElements.map(instantiate);
            // 3. è·å– å­©å­-html-æ•°ç»„
            const childDoms = childInstances.map(childInstance => childInstance.dom);

            // 4. å„¿/å¥³ åŠ å…¥ çˆ¸çˆ¸å¦ˆå¦ˆçš„æ€€æŠ±, ã€Œ html ç»„åˆ ã€
            // æ­£å¦‚ -2- æ‰€åšçš„-é€’å½’æœ¬å‡½æ•°
            // æ‰€ä»¥-å­™å­/å­™å¥³-å·²ç»-åŠ å…¥-å„¿/å¥³çš„æ€€æŠ±äº†
            childDoms.forEach(childDom => dom.appendChild(childDom));

            const instance = { dom, element, childInstances };

            // `element` -> `Didact å…ƒç´ `

            // `dom` -> `html å…ƒç´ `

            // `childInstances`æ˜¯ä¸€ä¸ªåŒ…å«å…ƒç´ -å­å…ƒç´ å®ä¾‹çš„æ•°ç»„ã€‚

            return instance;
        }

        function tick() {
            const time = new Date().toLocaleTimeString();
            const clockElement = createElement("h1", null, time);
            render(clockElement, rootDom);
        }

        tick();
        setInterval(tick, 1000);

        /** â¬‡ï¸â¬‡ï¸â¬‡ï¸â¬‡ï¸â¬‡ï¸ ğŸŒ¼DidactğŸŒ¼ â¬‡ï¸â¬‡ï¸â¬‡ï¸â¬‡ï¸â¬‡ï¸ **/

        function createElement(type, config, ...args) {
            const props = Object.assign({}, config);
            const hasChildren = args.length > 0;
            const rawChildren = hasChildren ? [].concat(...args) : [];
            props.children = rawChildren.
                filter(c => c != null && c !== false).
                map(c => c instanceof Object ? c : createTextElement(c));
            return { type, props };
        }

        function createTextElement(value) {
            return createElement("TEXT ELEMENT", { nodeValue: value });
        }
    </script>
</body>

</html>